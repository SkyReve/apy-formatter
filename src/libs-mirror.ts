import * as vscode from "vscode";
import {
  pathExists,
  ensureDirectory,
  writeFileUtf8,
  readTextFile,
  deleteFileIfExists,
  getReveApyRoots,
  getRelativePath,
} from "./utils";

type FileFilter = (name: string, type: vscode.FileType) => boolean;

const CACHE_DIRS = new Set(["__pycache__", ".pytest_cache", ".mypy_cache"]);

async function walkDirectory(
  directory: vscode.Uri,
  filter: FileFilter,
): Promise<vscode.Uri[]> {
  const result: vscode.Uri[] = [];

  async function walk(current: vscode.Uri): Promise<void> {
    let entries: [string, vscode.FileType][];
    try {
      entries = await vscode.workspace.fs.readDirectory(current);
    } catch {
      return;
    }

    for (const [name, type] of entries) {
      const child = vscode.Uri.joinPath(current, name);

      if (type === vscode.FileType.Directory) {
        if (!CACHE_DIRS.has(name)) await walk(child);
      } else if (filter(name, type)) {
        result.push(child);
      }
    }
  }

  await walk(directory);
  return result;
}

function collectApyFilesUnder(directory: vscode.Uri): Promise<vscode.Uri[]> {
  return walkDirectory(
    directory,
    (name, type) => type === vscode.FileType.File && name.toLowerCase().endsWith(".apy"),
  );
}

function listAllFilesUnder(directory: vscode.Uri): Promise<vscode.Uri[]> {
  return walkDirectory(directory, (_, type) => type === vscode.FileType.File);
}

async function ensureInitPyForDirectory(directory: vscode.Uri): Promise<void> {
  const initPy = vscode.Uri.joinPath(directory, "__init__.py");
  if (!(await pathExists(initPy))) {
    await writeFileUtf8(initPy, "# <auto-generated package marker>\n");
  }
}

async function pruneEmptyDirectoriesUpward(
  startDirectory: vscode.Uri,
  stopDirectory: vscode.Uri,
): Promise<void> {
  let current = startDirectory;

  while (true) {
    if (current.toString() === stopDirectory.toString()) return;

    let entries: [string, vscode.FileType][];
    try {
      entries = await vscode.workspace.fs.readDirectory(current);
    } catch {
      return;
    }

    const hasRealFile = entries.some(
      ([name, type]) => type === vscode.FileType.File && name !== "__init__.py",
    );
    const hasSubDirectory = entries.some(
      ([, type]) => type === vscode.FileType.Directory,
    );
    if (hasRealFile || hasSubDirectory) return;

    const initPy = vscode.Uri.joinPath(current, "__init__.py");
    if (await pathExists(initPy)) {
      await deleteFileIfExists(initPy);
    }

    try {
      await vscode.workspace.fs.delete(current, {
        recursive: false,
        useTrash: false,
      });
    } catch {
      return;
    }

    current = vscode.Uri.joinPath(current, "..");
  }
}

export async function syncLibsApyMirror(
  workspaceFolder: vscode.WorkspaceFolder,
): Promise<void> {
  const libsRoot = vscode.Uri.joinPath(workspaceFolder.uri, "src", "libs");
  if (!(await pathExists(libsRoot))) return;

  const { base, libs: mirrorRoot } = getReveApyRoots(workspaceFolder);
  await ensureDirectory(base);
  await ensureDirectory(mirrorRoot);

  const apyFiles = await collectApyFilesUnder(libsRoot);
  const desiredFiles = new Set<string>();

  for (const apyUri of apyFiles) {
    const relativePath = getRelativePath(libsRoot, apyUri);
    const relativePathWithoutExt = relativePath.replace(/\.apy$/i, "");
    const pyRelativePath = `${relativePathWithoutExt}.py`;
    desiredFiles.add(pyRelativePath);

    const pathParts = pyRelativePath.split("/");
    let currentDirectory = mirrorRoot;
    for (let i = 0; i < pathParts.length - 1; i++) {
      currentDirectory = vscode.Uri.joinPath(currentDirectory, pathParts[i]);
      await ensureDirectory(currentDirectory);
      await ensureInitPyForDirectory(currentDirectory);
    }

    const targetPyUri = vscode.Uri.joinPath(
      mirrorRoot,
      ...pyRelativePath.split("/"),
    );

    const apyText = await readTextFile(apyUri);
    if (apyText == null) continue;

    const header = [
      "# <auto-generated from src/libs/*.apy>",
      "from __future__ import annotations",
      "from apy_runtime import Reve, Response, logger, exceptions, Http400, Http401, Http403, Http404, Http409, Http410, Http500, AccessToken, RefreshToken",
      "",
    ].join("\n");

    await writeFileUtf8(targetPyUri, header + apyText + "\n");
  }

  const allMirrorFiles = await listAllFilesUnder(mirrorRoot);

  for (const fileUri of allMirrorFiles) {
    const relativePath = getRelativePath(mirrorRoot, fileUri);

    if (relativePath.endsWith("/__init__.py") || relativePath === "__init__.py")
      continue;
    if (!relativePath.toLowerCase().endsWith(".py")) continue;

    if (!desiredFiles.has(relativePath)) {
      await deleteFileIfExists(fileUri);
      const parentDirectory = vscode.Uri.joinPath(fileUri, "..");
      await pruneEmptyDirectoriesUpward(parentDirectory, mirrorRoot);
    }
  }
}
