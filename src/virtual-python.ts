import * as vscode from "vscode";
import { DEFAULT_INDENT, VirtualPythonInfo } from "./types";
import {
  getWorkspaceFolderForUri,
  ensureDirectory,
  writeFileUtf8,
  hashUri,
  getReveApyRoots,
} from "./utils";
import { getTopLevelLibImports, computeDeepLibImports } from "./lib-imports";

export async function buildVirtualPython(
  apyUri: vscode.Uri,
  apyText: string,
): Promise<{ text: string; prefixLineCount: number }> {
  const topLevelImports = await getTopLevelLibImports(apyUri);
  const deepImports = await computeDeepLibImports(
    apyUri,
    apyText,
    topLevelImports,
  );

  const headerLines: string[] = [
    "# <auto-generated by APY VSCode extension>",
    "from __future__ import annotations",
    "from apy_runtime import Reve, Response, logger, exceptions, Http400, Http401, Http403, Http404, Http409, Http410, Http500, AccessToken, RefreshToken",
    ...topLevelImports.map((moduleName) => `import ${moduleName}`),
    ...deepImports.map((moduleName) => `import ${moduleName}`),
    "",
    "def run(reve: Reve) -> Response:",
  ];

  const prefix = headerLines.join("\n") + "\n";
  const prefixLineCount = prefix.split("\n").length - 1;

  const lines = apyText.split(/\r?\n/);
  const body = lines.map((line) => DEFAULT_INDENT + line).join("\n");

  return { text: prefix + body + "\n", prefixLineCount };
}

export async function writeVirtualPyFile(
  apyUri: vscode.Uri,
  content: string,
): Promise<vscode.Uri> {
  const workspaceFolder = getWorkspaceFolderForUri(apyUri);
  if (!workspaceFolder)
    throw new Error(
      "APY: No workspace folder found for this .apy file. Please open a folder or workspace in VS Code.",
    );

  const { base } = getReveApyRoots(workspaceFolder);
  await ensureDirectory(base);

  const fileName = `${hashUri(apyUri)}.py`;
  const pyUri = vscode.Uri.joinPath(base, fileName);

  await writeFileUtf8(pyUri, content);
  return pyUri;
}

export async function ensureDocumentAnalyzed(pyUri: vscode.Uri): Promise<void> {
  try {
    await vscode.workspace.openTextDocument(pyUri);
  } catch {
    // ignore
  }
}

export function isApyRuntimeNoiseDiagnostic(
  diagnostic: vscode.Diagnostic,
): boolean {
  const message = diagnostic.message.toLowerCase();
  return (
    message.includes("apy_runtime") &&
    (message.includes("import") ||
      message.includes("could not be resolved") ||
      message.includes("reportmissingimports"))
  );
}

export function mapDiagnosticsToApy(
  virtualDiagnostics: readonly vscode.Diagnostic[],
  info: VirtualPythonInfo,
): vscode.Diagnostic[] {
  const mappedDiagnostics: vscode.Diagnostic[] = [];

  for (const diagnostic of virtualDiagnostics) {
    const start = diagnostic.range.start;
    const end = diagnostic.range.end;

    if (start.line < info.prefixLineCount) continue;

    const newStartLine = start.line - info.prefixLineCount;
    const newEndLine = end.line - info.prefixLineCount;

    const newStartChar = Math.max(0, start.character - info.indentSize);
    const newEndChar = Math.max(0, end.character - info.indentSize);

    const range = new vscode.Range(
      new vscode.Position(newStartLine, newStartChar),
      new vscode.Position(newEndLine, newEndChar),
    );

    const mappedDiagnostic = new vscode.Diagnostic(
      range,
      diagnostic.message,
      diagnostic.severity,
    );
    mappedDiagnostic.code = diagnostic.code;
    mappedDiagnostic.source = diagnostic.source ?? "pyright";
    mappedDiagnostic.relatedInformation = diagnostic.relatedInformation;
    mappedDiagnostics.push(mappedDiagnostic);
  }

  return mappedDiagnostics;
}

// Re-export from schema for backward compatibility
export { APY_RUNTIME_COMPLETIONS } from "./apy-runtime-schema";
